# -*- coding: utf-8 -*-
"""preprocesamiento.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1H9t-NCki_xaXlZCBNeqQblhfhqJ5JyDp
"""

import numpy as np
import pandas as pd
import sqlite3 as sql
from mlxtend.preprocessing import TransactionEncoder

from google.colab import drive
drive.mount('/content/drive')

from google.colab import files 
src = list(files.upload().values())[0] 
open('exploracion.py','wb').write(src) 
import exploracion

#extraer db de el archivo py
movies=exploracion.dbmovies()
ratings=exploracion.dbratings()

"""# **Preprocesamiento-Creación de tabla SQL**"""

# Conectar a la base de datos
conn = sql.connect('/content/drive/MyDrive/Analitica III/MARKETING/db_movies (1)')
##conn = sqlite3.connect('db_movies (1)')
# Borrar la tabla si existe
conn.execute('DROP TABLE IF EXISTS usuarios_sel;')

#######crear tabla con usuarios con más de 50 peliculas vistas y menos de 1000
query = '''
    CREATE TABLE usuarios_sel AS
    SELECT userId,count(*) as cnt_rat
    from ratings
    group by userId
    having cnt_rat <=1000
    order by cnt_rat asc
'''
conn.execute(query)

# Borrar la tabla si existe
conn.execute('DROP TABLE IF EXISTS peliculas_sel;')

####crear tabla con peliculas que han sido vistas por más de 50 usuarios
query2 = '''
    CREATE TABLE peliculas_sel AS
    SELECT movieId,count(*) as cnt_rat
    from ratings
    group by "movieId"
    having cnt_rat>=10
    order by cnt_rat desc
'''
conn.execute(query2)

# Borrar la tabla si existe
conn.execute('DROP TABLE IF EXISTS ratings_final;')

####crear tablas filtradas de peliculas, usuarios y calificaciones

query3 = '''
    CREATE TABLE ratings_final AS
    SELECT A.userId, A.movieId,A.rating,A.timestamp
    from ratings A
    INNER JOIN peliculas_sel B ON B.movieId=A.movieId
    INNER JOIN usuarios_sel C ON C.userId=A.userId;
'''
conn.execute(query3)

# Borrar la tabla si existe
conn.execute('DROP TABLE IF EXISTS peliculas_final;')

####crear tablas filtradas de peliculas, usuarios y calificaciones

query4 = '''
    CREATE TABLE peliculas_final AS
    SELECT A.movieId,A.title,A.genres
    from movies A
    INNER JOIN peliculas_sel B ON B.movieId=A.movieId
'''
conn.execute(query4)

#######crear tabla completa

# Borrar la tabla si existe
conn.execute('DROP TABLE IF EXISTS full_ratings;')

####crear tabla con todo

query5 = '''
    CREATE TABLE full_ratings AS
    SELECT A.userId, B.movieId,A.rating,A.timestamp,B.title,B.genres
    from ratings_final A
    INNER JOIN peliculas_final B ON B.movieId=A.movieId
'''
conn.execute(query5)

#traer el cur del archivo py
cur=exploracion.cur

cur.execute("SELECT name FROM sqlite_master WHERE type='table';")

print(cur.fetchall())

"""verficar tamaño de tablas con filtros

"""

####peliculas

pd.read_sql('select count(*) from movies', conn)

pd.read_sql('select count(*) from peliculas_final', conn)

##ratings
pd.read_sql('select count(*) from ratings', conn)

pd.read_sql('select count(*) from ratings_final', conn)

## 3 tablas cruzadas ###
pd.read_sql('select count(*) from full_ratings', conn)

ratings=pd.read_sql('select * from full_ratings',conn)
ratings.duplicated().sum() ## al cruzar tablas a veces se duplican registros
ratings.info()
ratings.head(10)

df = pd.read_sql('select * from full_ratings', conn)
df

# Extraer el año utilizando una expresión regular y la función str.extract()
df['year'] = df['title'].str.extract('\((\d{4})\)')

# Eliminar el espacio que separa el título y el año
df['title'] = df['title'].str.replace(r'\s*\(\d{4}\)', '', regex=True)
df

#ratings=pd.read_sql("""select * from full_ratings""",conn)
genres=ratings['genres'].str.split('|')
te = TransactionEncoder()
genres = te.fit_transform(genres)
genres = pd.DataFrame(genres, columns = te.columns_)
genres

df.columns

### tabla de df se utilizara para modelos #####

df = pd.concat([df,genres], axis=1)
df = df.drop(['genres'], axis=1)
df

df.to_sql('df', conn, if_exists='replace')

#Importar csv a drive
df.to_csv('/content/drive/MyDrive/Analitica III/MARKETING/df.csv', index=False, mode='w')

df_1 = pd.read_sql('select * from full_ratings', conn)
df_1