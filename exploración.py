# -*- coding: utf-8 -*-
"""exploración.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aGBPIpDkpDWMcJR3BEiBMAaefdtU6tqX

# **Importar Datos**
"""

import numpy as np
import pandas as pd
import os  ### para ver y cambiar directorio de trabajo
import sqlite3 as sql
import plotly.graph_objs as go ### para gráficos
import plotly.express as px
from mlxtend.preprocessing import TransactionEncoder
#import sqlite3
#import sqlite3 as sql
#from sklearn.metrics.pairwise import cosine_similarity
#from sklearn.feature_extraction.text import CountVectorizer
#from ipywidgets import interact
#import ipywidgets as interact
#from IPython.display import display
#from surprise import Reader, Dataset
#from surprise.model_selection import cross_validate, GridSearchCV
#from surprise import KNNBasic, KNNWithMeans, KNNWithZScore, KNNBaseline
#from surprise.model_selection import train_test_split
#from sklearn.feature_extraction.text import TfidfVectorizer

#os.getcwd() ## ver directorio actual
#os.chdir('/content') ### cambiar directorio a ruta específica

from google.colab import drive
drive.mount('/content/drive')

##### conectarse a BD #######

conn = sql.connect('/content/drive/MyDrive/Analitica III/MARKETING/db_movies (1)')
#conn=sql.connect('/content/drive/MyDrive/db_movies')
cur=conn.cursor()

cur.execute("SELECT name FROM sqlite_master WHERE type='table';")

print(cur.fetchall())

#######
############ traer tabla de BD a python ####

movies= pd.read_sql("""select *  from movies""", conn)
ratings = pd.read_sql('select * from ratings', conn)

"""# **Exploración Inicial**

## **Movies**
"""

### Identificar campos de cruce y verificar que estén en mismo formato ####
### verificar duplicados
movies.info()
##No se tienen Nulos, tienen los mismo registros

movies.duplicated().sum()

def dbmovies():
  movies=pd.read_sql("""select * from movies """, conn)
  genres=movies['genres'].str.split('|')
  te = TransactionEncoder()
  genres = te.fit_transform(genres)
  genres = pd.DataFrame(genres, columns = te.columns_)
  movies
  return movies
dbmovies()

"""## **Ratings**"""

### Identificar campos de cruce y verificar que estén en mismo formato ####
### verificar duplicados
ratings.info()
##No se tienen Nulos, tienen los mismos registros en todos las columnas

ratings.duplicated().sum()

def dbratings():
  ratings=pd.read_sql("""select * from ratings """, conn)
  return ratings
dbratings()

"""# **Descripción base**"""

###Calcular la distribución de calificaciones
cr=pd.read_sql(""" select rating,
                          count(*) as conteo 
                          from ratings
                          group by rating
                          order by conteo desc""", conn)
###Nombres de columnas con numeros o guiones se deben poner en doble comilla para que se reconozcan
###Los que estan en 0 se consideran leidos pero no calificados
#### Se conoce como calificación implicita, consume producto pero no da una calificacion
cr = cr.sort_values(by='conteo',ascending=False)

# Crear la figura de barras
data = go.Bar(x=cr.rating, y=cr.conteo, text=cr.conteo, textposition="outside")
layout = go.Layout(title="Count of ratings", xaxis={'title':'Rating'}, yaxis={'title':'Count'})
fig = go.Figure(data=data, layout=layout)

# Mostrar la figura
fig.show()

### calcular cada usuario cuátos libros calificó
rating_users=pd.read_sql(''' select userId,
                         count(*) as cnt_rat
                         from ratings
                         group by userId
                         order by "cnt_rat" asc
                         ''',conn )

fig  = px.histogram(rating_users, x= 'cnt_rat', title= 'Hist frecuencia de numero de calificaciones por usario')
fig.show()

#### Se ve la mayor parte de usuarios calificando entre 0 y 300 peliculas

#### filtrar usuarios con más de 50 libros calificados (para tener calificaion confiable) y los que tienen menos de mill porque pueden ser no razonables
rating_users2=pd.read_sql(''' select userId,
                         count(*) as cnt_rat
                         from ratings
                         group by userId
                         having cnt_rat <=1000
                         order by cnt_rat asc
                         ''',conn )
rating_users2

### ver distribucion despues de filtros,ahora se ve mas razonables
rating_users2.describe()

### graficar distribucion despues de filtrar datos
fig  = px.histogram(rating_users2, x= 'cnt_rat', title= 'Hist frecuencia de numero de calificaciones por usario')
fig.show()

#### verificar cuantas calificaciones tiene cada pelicula
rating_movies=pd.read_sql(''' select movieId,
                         count(*) as cnt_rat
                         from ratings
                         group by "movieId"
                         order by cnt_rat desc
                         ''',conn )

rating_movies

### graficar distribucion

fig  = px.histogram(rating_movies, x= 'cnt_rat', title= 'Hist frecuencia de numero de calificaciones para cada película')
fig.show()

####Filtrar películas que tengan más de 20 calificaciones 
rating_movies2=pd.read_sql(''' select movieId,
                         count(*) as cnt_rat
                         from ratings
                         group by "movieId"
                         having cnt_rat>=20
                         order by cnt_rat desc
                         ''',conn )
rating_movies2.describe()

fig  = px.histogram(rating_movies2, x= 'cnt_rat', title= 'Hist frecuencia de numero de calificaciones para cada película')
fig.show()